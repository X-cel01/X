<!--
--  Uploaded on : https://haxor.my.id/open/xxccd.html
--  Official Web : https://prinsh.com
--  script-deface-generator.prinsh.com
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ðŸ”¥ Shader Berat Apiess 9000</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }
  </style>
</head>
<body>
<canvas id="c1"></canvas>

<!-- ðŸŽµ AUTO PLAY MUSIK -->
<audio id="bgm" autoplay loop hidden>
  <source src="https://files.catbox.moe/po2h5u.mp3" type="audio/mpeg">
</audio>

<script>
const canvas = document.getElementById("c1");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const gl = canvas.getContext("webgl");

// VERTEX SHADER
const vertexShaderSource = `
attribute vec4 position;
varying vec2 uv;
void main() {
  uv = position.xy * 0.5 + 0.5;
  gl_Position = position;
}`;

// FRAGMENT SHADER SUPER BERAT
const fragmentShaderSource = `
precision highp float;
varying vec2 uv;
uniform float time;
uniform vec2 resolution;

float fractal(vec3 p) {
  float a = 0.0;
  float scale = 1.0;
  for (int i = 0; i < 15; i++) {
    p = abs(p) / dot(p, p) - 0.8 + sin(p.yzx * 4.0 + time) * 0.3;
    a += length(p) * 0.4 * scale;
    scale *= 0.95;
  }
  return a;
}

void main() {
  vec2 uv2 = uv * 2.0 - 1.0;
  uv2.x *= resolution.x / resolution.y;

  vec3 ro = vec3(0.0, 0.0, time * 0.1);
  vec3 rd = normalize(vec3(uv2, -1.5));

  float total = 0.0;
  vec3 p;
  for (int i = 0; i < 64; i++) {
    p = ro + float(i) * 0.08 * rd;
    float d = fractal(p);
    total += exp(-d * 1.5);
  }

  vec3 col = vec3(
    sin(total * 2.0 + time * 0.1),
    cos(total * 1.5 + time * 0.2),
    sin(total * 3.0 + time * 0.3)
  );

  col *= smoothstep(0.1, 1.5, total);
  col = pow(col, vec3(1.5)) * 1.2;

  float r = fractal(p + vec3(0.01, 0.0, 0.0));
  float g = fractal(p + vec3(0.0, 0.01, 0.0));
  float b = fractal(p + vec3(0.0, 0.0, 0.01));

  gl_FragColor = vec4(col.r * r, col.g * g, col.b * b, 1.0);
}`;

function compileShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
    return null;
  }
  return shader;
}

const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);
const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
const program = gl.createProgram();

gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

// Geometry
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
const positions = [
  -1, -1, 1, -1,
  -1,  1, -1,  1,
   1, -1, 1,  1,
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

const positionLocation = gl.getAttribLocation(program, "position");
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const resolutionLocation = gl.getUniformLocation(program, "resolution");
const timeLocation = gl.getUniformLocation(program, "time");

function render(t) {
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
  gl.uniform1f(timeLocation, t * 0.001);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(render);
}

requestAnimationFrame(render);

// Optional: Play musik di klik pertama user jika browser blokir autoplay
document.addEventListener("click", () => {
  const audio = document.getElementById("bgm");
  if (audio.paused) audio.play();
});
</script>
</body>
</html>